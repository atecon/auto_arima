function void y_is_constant (bundle *self)
    /* Check whether y is constant. Set self.error as TRUE of y is constant.*/

    series y = self.y

    if isconst(y) == TRUE
        if self.verbose > 0
            printError(sprintf("Endogenous series '%s' is constant..", self.name_yseries))
        endif
        self.error = TRUE
    endif
end function


function void add_intercept_to_xlist (bundle *self)
    /* Add intercept to xlist if it should enter the model. */

    if !inlist(self.xlist, "const") && self.with_intercept == TRUE
        if self.verbose == 1
            printWarning("Intercept added to xlist as you set intercept to TRUE.")
        endif
        self.xlist += const
        self.intercept_added = TRUE
    endif
end function

function void check_intercept_settings (bundle *self)
    /* */

    if inlist(self.xlist, "const") && self.with_intercept == FALSE
        printError(sprintf("You set the parameter 'with_intercept' to FALSE but \n\
          included it to the list of exogenous. Abort."))

        self.error = TRUE
    endif
end function

function void drop_intercept_from_xlist (bundle *self)
    /* Drop intercept from xlist if it should not enter the model. */

    if inlist(self.xlist, "const") && self.with_intercept == FALSE
        self.xlist -= const
        if self.verbose
            printInfo("Intercept has been dropped.")
        endif
    endif
end function

function void do_initial_checks (bundle *self)
    /* Perform initial checks and drop optionally intercept. */

    y_is_constant(&self)
    check_intercept_settings(&self)
    drop_intercept_from_xlist(&self)
end function

function scalar data_has_seasonality (void)
    /* Flag seasonality of data set */

    return ($pd > 1) ? 1 : 0
end function


function bundle set_bundle_and_get_defaults (const series y,
                                             bundle opts[null])
    /* Compile self bundle by merging eventual information
    from 'opts' bundle. */

    if !exists(opts)
        bundle opts = null
    endif

    bundle self = default_values(y)
    self = opts + self			# override defaults

    clean_up_self(&self)

    return self
end function


function void clean_up_self (bundle *self)
    /* */

    delete self.methods_supported --force
end function

function bundle default_values (const series y)
    /* Set default values */

    bundle self = null
    scalar self.error = FALSE
    scalar self.y_is_constant = FALSE
    scalar self.with_intercept = TRUE
    scalar self.intercept_added = FALSE
    scalar self.with_seasonality = data_has_seasonality()
    scalar self.verbose = 1
    list self.xlist = null

    strings self.methods_supported  = defarray("exact_ml", "conditional_ml")
    string self.estimation_method = "exact_ml" # gretl built-in default

    # arima parameters
    scalar self.min_p = 0
    scalar self.max_p = 1   # TODO: $pd
    scalar self.min_d = 0
    scalar self.max_d = 1
    scalar self.min_q = 0
    scalar self.max_q = 1

    # seasonal arima parameters
    scalar self.min_D = 0
    scalar self.max_D = (self.with_seasonality == TRUE) ? 1 : 0
    scalar self.min_P = 0
    scalar self.max_P = (self.with_seasonality == TRUE) ? 1 : 0
    scalar self.min_Q = 0
    scalar self.max_Q = (self.with_seasonality == TRUE) ? 1 : 0

    return self
end function


function strings get_info_criteria_names (void)
    return defarray("aicc", "aic", "bic", "hqc")
end function


function strings get_parameter_names (void)
    if data_has_seasonality()
        return defarray("p", "d", "q", "P", "D", "Q")
    else
        return defarray("p", "d", "q")
    endif
end function


function void add_n_combinations (bundle *self)
    /* Compute number of parameter combinations. */

    scalar n = 1
    strings parameters = get_parameter_names()

    loop foreach i parameters
        string param = parameters[i]
        scalar n *= (1 + self.max_@param - self.min_@param)
    endloop

    scalar self.n_combinations = n
end function


function void add_data_to_bundle (bundle *self,
                                  const series y,
                                  const list xlist[null])
    /* */

    series self.y = y
    list self.xlist += xlist
    add_intercept_to_xlist(&self)

    self.name_yseries = argname(y)
    string self.name_xlist = ""
    self.name_xlist = (nelem(xlist)) ? argname(xlist) : self.name_xlist
end function


function bundle auto_arima (const series y "Endogenous",
                            const list xlist[null] "Exogenous",
                            bundle opts[null] "Parameter bundle")

    # TODO: User passes a bundle with key-values referencing to min_/max_p etc

    if !exists(opts)
        bundle opts = null
    endif

    bundle self = set_bundle_and_get_defaults(y, opts)
    add_data_to_bundle(&self, y, xlist)
    do_initial_checks(&self)
    if self.error
        return self
    endif

    prepare_arima_options_string(&self)

    add_n_combinations(&self)
    matrix self.parameter_matrix = get_parameter_matrix(self)
    matrix self.criteria_values = initialize_criteria_values_mat(self)

    estimate_models(&self)
    rank_models_by_criteria(&self)

    return self
end function

function matrix get_auto_arima_parameters (const bundle self,
                                           const string info_criteria,
                                           const int model_rank[1::])
    /* Retrieve the vector of ARIMA parameters of the the i-th best model for a specific information criterion. */

    errorif(model_rank > self.n_combinations, sprintf("Selected model rank (%d) exceeds number of models estimated (%d).", model_rank, self.n_combinations))

    matrix pos_info_criteria = instrings(get_info_criteria_names(), info_criteria)

    errorif(!nelem(pos_info_criteria), sprintf("Information criteria '%s' unknown.", info_criteria))

    scalar parameter_combination = self.model_rank_by_criteria[model_rank, pos_info_criteria]

    return self.parameter_matrix[parameter_combination,]
end function


function strings row_labels (const bundle self)
    /* Compile row lables for summary table. */

    strings row_labels = array(self.n_combinations)

    loop j=1..rows(self.parameter_matrix)
        string label = sprintf("%d|%d|%d", self.parameter_matrix[j,1], self.parameter_matrix[j,2], self.parameter_matrix[j,3])

        if data_has_seasonality()
            label += sprintf(" |%d|%d|%d", self.parameter_matrix[j,4], self.parameter_matrix[j,5], self.parameter_matrix[j,6])
        endif

        row_labels[j] = label
    endloop

    return row_labels
end function


function string asterisks (const int position[1::])
    if position == 1
        return "***"
    elif position == 2
        return "**"
    elif position == 3
        return "*"
    else
        return ""
    endif
end function


function void print_table_and_row_labels (const bundle self)
    /* Print actual summary values and row labels */

    strings row_labels = row_labels(self)
    strings criteria_names = get_info_criteria_names()
    string asterisks

    printf "\n"
    loop j=1..rows(self.parameter_matrix)
        printf "%s ", row_labels[j]

        # actual value plus asterisks indicating rank of model specification
        loop i=1..nelem(criteria_names)
            printf "%12.3f%s", self.criteria_values[j,i], asterisks(self.model_rank_by_criteria[j,i])
        endloop
        printf "\n"
    endloop
end function

function void print_summary_intro (const bundle self)
    printf "\t\tSummary results of ARIMA model combinations\n\n"
    print "Three, two and one asterisk(s) below indicate the 1st, 2nd and 3rd best (that"
    print "is, minimized) values of the respective information criteria, AIC = Akaike"
    print "criterion, AICC = corrected AIC, BIC = Schwarz Bayesian criterion and"
    print "HQC = Hannan-Quinn criterion across all ARIMA model specification."
    printf "\nCommon sample used for all models: %s to %s", self.sample_start, self.sample_end
end function


function void print_table_border (void)
    printf "\n*******************************************************************\n"
end function

function void print_table_header (void)
    strings criteria_names = get_info_criteria_names()

    printf "\n\nARIMA-spec. \t"
    loop foreach i criteria_names
        printf "$i \t\t"
    endloop
    printf "\n-----------------------------------------------------------\n"
end function

function void print_auto_arima_results (const bundle self)
    /* Summarize parameter results for each information criteria. */

    errorif(self.error == TRUE, "The auto_arima() function throw some error. Please check.")
    print_table_border()
    print_summary_intro(self)
    print_table_header()
    print_table_and_row_labels(self)
    print_table_border()
end function


function string get_auto_arima_command (const bundle self,
                                        const string info_criteria,
                                        const int model_rank)
    /* Compile gretl command of a model selected by information criteria and rank. */

    errorif(self.error == TRUE, "The auto_arima() function throw some error. Please check.")
    matrix beta = get_auto_arima_parameters(self, info_criteria, model_rank)

    string cmd = sprintf("arima %d %d %d", beta[1], beta[2], beta[3])
    if data_has_seasonality()
        cmd += sprintf(" ; %d %d %d", beta[4], beta[5], beta[6])
    endif

    if self.with_intercept == TRUE && self.intercept_added == TRUE
        # passed xlist did not include 'const'
        cmd += sprintf(" ; %s const %s %s", self.name_yseries, self.name_xlist, self.arima_model_options_string)
        #elif self.with_intercept == TRUE && self.intercept_added == FALSE
        # passed xlist did already include 'const'
        #    cmd += sprintf(" ; %s %s %s", self.name_yseries, self.name_xlist, self.arima_model_options_string)
    else
        cmd += sprintf(" ; %s %s %s", self.name_yseries, self.name_xlist, self.arima_model_options_string)
    endif

    return cmd
end function


function void rank_models_by_criteria (bundle *self)
    /* Rank models by information criteria. */

    matrix criteria_values = seq(1, self.n_combinations)' ~ self.criteria_values
    matrix model_rank_by_criteria = initialize_criteria_values_mat(self)
    strings criteria_names = get_info_criteria_names()

    loop foreach i criteria_names
        model_rank_by_criteria[,i] = msortby(criteria_values, 1+i)[,1]
    endloop

    cnameset(model_rank_by_criteria, criteria_names)
    self.model_rank_by_criteria = model_rank_by_criteria
end function


function void get_parameters (const matrix parameter_matrix,
                              scalar *p,
                              scalar *d,
                              scalar *q,
                              scalar *P[null],
                              scalar *D[null],
                              scalar *Q[null])
    /* Retrieve sarima parameters from overall parameter matrix. */

    scalar p = parameter_matrix[1]
    scalar d = parameter_matrix[2]
    scalar q = parameter_matrix[3]
    if data_has_seasonality()
        scalar P = parameter_matrix[4]
        scalar D = parameter_matrix[5]
        scalar Q = parameter_matrix[6]
    endif
end function

function matrix initialize_criteria_values_mat (const bundle self)
/* code description
    return: type, description */

    matrix criteria_values = mshape(NA, rows(self.parameter_matrix), nelem(get_info_criteria_names()))
    cnameset(criteria_values, get_info_criteria_names())

    return criteria_values
end function


function void estimate_models (bundle *self)
    /* Estimate SARIMAX models for all parameter combinations. */

    series y = self.y
    list xlist = self.xlist

    # Restrict the data set to the least common sample to ensure that information criteria a comparable
    # TODO:is this offset computation correct?
    scalar offset = max(self.parameter_matrix)
    smpl +offset ;
    string self.sample_start = obslabel($t1)
    string self.sample_end = obslabel($t2)

    loop i=1..rows(self.parameter_matrix)
        self.criteria_values[i,] = arima_estimation_get_info_crits(y, xlist, self, $i)
    endloop
end function


function string final_model_options_string (const bundle self)
/* code description
    return: type, description */

    return (self.verbose == 0) ? self.arima_model_options_string : (self.verbose == 1 ? "--quiet" : "--verbose")
end function


function matrix arima_estimation_get_info_crits (const series y,
                                                 const list xlist,
                                                 const bundle self,
                                                 const int parameter_set_id[1::])
    /* Actual estimation of SARIMAX model and computation of information criteria. */

    string arima_model_options_string = final_model_options_string(self)
    scalar p, d, q, P, D, Q
    strings criteria_names = get_info_criteria_names()
    matrix criteria_values = mshape(NA, 1, nelem(criteria_names))

    get_parameters(self.parameter_matrix[parameter_set_id,], &p, &d, &q, &P, &D, &Q)

    if data_has_seasonality()
        catch arima p d q ; P D Q; y xlist @arima_model_options_string
    else
        catch arima p d q ; y xlist @arima_model_options_string
    endif

    if ($error || !inbundle($model, "aic")) && self.verbose
        printWarning(sprintf("Failed to estimated SARIMAX(%d,%d,%d,%d,%d,%d) model. Ignored.", p, d, q, P, D, Q))
    else
        loop foreach i criteria_names
            if criteria_names[i] != "aicc"
                string crit = sprintf("$%s", criteria_names[i])
                criteria_values[i] = @crit
            else
                criteria_values[i] = aicc($model)
            endif
        endloop
    endif

    return criteria_values
end function


function scalar aicc (const bundle model)
    /* Compute the corrected AIC criteria. */

    scalar aic = model.aic
    scalar n = model.T
    scalar k = model.ncoeff

    return aic + (2 * k * (k+1)) / (n-k-1)
end function


function void set_sarima_parameters_to_nan (bundle *self)
    /* Remove seasonal arima parameters from bundle if not needed. */

    if data_has_seasonality() == FALSE
        scalar self.min_D = NA
        scalar self.max_D = NA
        scalar self.min_P = NA
        scalar self.max_P = NA
        scalar self.min_Q = NA
        scalar self.max_Q = NA
    endif
end function


function matrix get_parameter_matrix (bundle self)
    /* Prepare matrix with all parameter combinations for ARIMA. */

    matrix combs = sarima_parameter_matrix(self)

    # Special treatment for non-seasonal case
    matrix combs = combs[,1:nelem(get_parameter_names())]   # Grab only p, d, q
    set_sarima_parameters_to_nan(&self)

    cnameset(combs, get_parameter_names())

    return combs
end function


function scalar n_lags (const int min_lag[0::], const int max_lag[0::])
    errorif(max_lag < min_lag, "Maximum lag cannot be lower than minimum lag.")
    return 1 + max_lag - min_lag
end function


function matrix sarima_parameter_matrix (const bundle self)
    /* Prepare the parameter combindations for SARIMA. */

    scalar k = 6        # p, d, q, P, D, Q
    scalar n_p = n_lags(self.min_p, self.max_p)
    scalar n_d = n_lags(self.min_d, self.max_d)
    scalar n_q = n_lags(self.min_q, self.max_q)
    scalar n_P = n_lags(self.min_P, self.max_P)
    scalar n_D = n_lags(self.min_D, self.max_D)
    scalar n_Q = n_lags(self.min_Q, self.max_Q)

    scalar n_rows = n_p * n_d * n_q * n_P * n_D * n_Q
    matrix combs = mshape(NA, n_rows, k)
    scalar repeat = 1

    # start with Q (the rightest variable)
    matrix m = ones(n_Q, (n_rows/n_Q)) .* seq(self.min_Q, self.max_Q)'
    combs[,6] = vec(m)

    repeat *= n_Q
    matrix m = ones(n_D, repeat) .* seq(self.min_D, self.max_D)'
    m = vec(m')
    scalar factor = n_p * n_d * n_q * n_P
    combs[,5] = vec(m .* ones(rows(m), factor))

    repeat *= n_D
    matrix m = ones(n_P, repeat) .* seq(self.min_P, self.max_P)'
    m = vec(m')
    scalar factor = n_p * n_d * n_q
    combs[,4] = vec(m .* ones(rows(m), factor))

    repeat *= n_P
    matrix m = ones(n_q, repeat) .* seq(self.min_q, self.max_q)'
    m = vec(m')
    scalar factor = n_p * n_d
    combs[,3] = vec(m .* ones(rows(m), factor))

    repeat *= n_q
    matrix m = ones(n_d, repeat) .* seq(self.min_d, self.max_d)'
    m = vec(m')
    scalar factor = n_p
    combs[,2] = vec(m .* ones(rows(m), factor))

    repeat *= n_d
    matrix m = ones(n_p, repeat) .* seq(self.min_p, self.max_p)'
    m = vec(m')
    combs[,1] = vec(m')

    return combs
end function


# TODO: many more options may be added -- see 'help arima'
function void prepare_arima_options_string (bundle *self)
    /* Compile various option strings for arima command. */

    string arima_model_options_string = ""

    arima_model_options_string = (self.with_intercept == FALSE) ? "--nc " : arima_model_options_string

    arima_model_options_string += (self.estimation_method == "conditional_ml") ? "--conditional" : ""

    self.arima_model_options_string = arima_model_options_string
end function


function scalar estimation_method_supported (const bundle self)
    /* */

    self.estimation_method = tolower(self.estimation_method)
    if instrings(self.methods_supported, self.estimation_method)
        return 1
    else
        printWarning(sprintf("Estimation method '%s' not supported.",\
          self.estimation_method))
        printInfo(sprintf("Will switch to %s method.", self.methods_supported[1]))
        self.estimation_method = self.methods_supported[1]
        return 0
    endif
end function


function void printInfo (const string s)
    printf "\nInfo: %s\n", s
end function

function void printWarning (const string s)
    printf "\nWarning: %s\n", s
end function

function void printError (const string s)
    printf "\nError: %s\n", s
end function


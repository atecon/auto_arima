function void y_has_zero_values (bundle *self)
    /* Check whether y includes only zero values.
    return: 0 if not zero or negative values, otherwise 1. */

    series y = self.y
    smpl y --no-missing

    if self.verbose > 0 && (sum(y == 0) > 0) ? TRUE : FALSE
        printWarning(sprintf("Endogenous '%s' includes only zero values", self.name_yseries))
        self.error = TRUE
    endif

end function


function void add_intercept_to_xlist (bundle *self)
    /* Add intercept to xlist if it should enter the model. */

    if !inlist(self.xlist, "const") && self.intercept == TRUE
        if self.verbose == 1
            printInfo("Intercept added to xlist as you set intercept == TRUE")
        endif
        self.xlist += const
    endif
end function


function void do_initial_checks (bundle *self)
    /* Perform initial checks and drop optionally intercept. */

    y_has_zero_values(&self)
    drop_intercept_from_xlist(&self)
end function

function scalar data_has_seasonality (void)
    /* Flag seasonality of data set */

    return ($pd > 1) ? 1 : 0
end function


function bundle set_bundle_and_get_defaults (const series y,
                                        bundle opts[null])
    /* Compile self bundle by merging eventual information
    from opts-bundle. */

    if !exists(opts)
        bundle opts = null
    endif

    bundle self = default_values(y)
    self = opts + self			# override defaults
    self.name_yseries = argname(y)

    return self
end function


function bundle default_values (const series y)
    /* Set default values */

    bundle self = null
    scalar self.error = FALSE
    scalar self.y_is_always_zero = FALSE
    scalar self.intercept = TRUE
    scalar self.seasonal = data_has_seasonality()
    scalar self.verbose = 1
    list self.xlist = null

    # TODO: still needed?
    strings self.methods_supported  = defarray("exact_ml", "conditional_ml")
    string self.estimation_method = "exact_ml"

    # arima parameters
    scalar self.min_p = 0
    scalar self.max_p = 1   # TODO: $pd
    scalar self.min_d = 1
    scalar self.max_d = 1
    scalar self.min_q = 1
    scalar self.max_q = 1

    # seasonal arima parameters
    if self.seasonal
        scalar self.min_D = 1		# TODO: makes sense?
        scalar self.max_D = 1
        scalar self.min_P = 0
        scalar self.max_P = 1
        scalar self.min_Q = 0
        scalar self.max_Q = 1
    endif

    # TODO: check for what these are
    #    scalar self.stationary = FALSE
    #    scalar self.stepwise = TRUE
    #    scalar self.nmodels = 94,
    #  trace = FALSE,
    #  approximation = (length(x) > 150 | frequency(x) > 12),
    #  method = NULL,
    #  truncate = NULL,
    #  test = c("kpss", "adf", "pp"),
    #  test.args = list(),
    #  seasonal.test = c("seas", "ocsb", "hegy", "ch"),
    #  seasonal.test.args = list(),
    #  allowdrift = TRUE,
    #  allowmean = TRUE,
    #  lambda = NULL,
    #  biasadj = FALSE,
    #  parallel = FALSE,
    #  num.cores = 2,

    return self
end function


function strings get_info_criteria_names (void)
    return defarray("aic", "bic", "hqc")
end function

function strings get_parameter_names (void)
    if data_has_seasonality()
        return defarray("p", "d", "q", "P", "D", "Q")
    else
        return defarray("p", "d", "q")
    endif
end function


function scalar n_combinations (const bundle self)
    /* Compute number of parameter combinations. */

    scalar n = 1
    strings parameters = get_parameter_names()

    loop foreach i parameters
        string param = parameters[i]
        scalar n *= (1 + self.max_@param - self.min_@param)
    endloop

    return n
end function


function bundle auto_arima (const series y "Endogenous",
                            const list xlist[null] "Exogenous",
                            bundle opts[null] "Parameter bundle")

    # TODO: User passes a bundle with key-values referencing to min_/max_p etc

    if !exists(opts)
        bundle opts = null
    endif
    bundle self = set_bundle_and_get_defaults(y, opts)

    series self.y = y
    list self.xlist = xlist
    string self.name_xlist = ""
    self.name_xlist = (nelem(xlist)) ? argname(xlist) : self.name_xlist

    do_initial_checks(&self)
    if self.error
        return self
    endif

    prepare_arima_options_string(&self)

    scalar self.n_combinations = n_combinations(self)
    matrix self.parameter_matrix = get_parameter_matrix(self)

    estimate_models(&self)
    rank_models_by_criteria(&self)

    return self
end function

function matrix get_auto_arima_parameters (const bundle self,
                                    const string info_criteria,
                                    const int model_rank[1::])
    /* Retrieve the vector of ARIMA parameters of the the i-th best model for a specific information criterion. */

    errorif(model_rank > self.n_combinations, sprintf("Selected model rank (%d) exceeds number of models estimated (%d).", model_rank, self.n_combinations))

    matrix pos_info_criteria = instrings(get_info_criteria_names(), info_criteria)
    errorif(!nelem(pos_info_criteria), sprintf("Information criteria '%s' unknown.", info_criteria))

    scalar parameter_combination = self.model_rank_by_criteria[model_rank, pos_info_criteria]

    return self.parameter_matrix[parameter_combination,]
end function


function void print_summary_header (void)
   /* Header printed print_auto_arima_results() is called. */

    strings criteria_names = get_info_criteria_names()
    printf "\n\np|d|q"
    if data_has_seasonality()
       printf " \t P|D|Q\t  "
    endif
    loop foreach i criteria_names
        # TODO: add asterisks for the 3 best combinations for each criteria
        printf "$i\t    "
    endloop
    printf "\n\n"
end function


function void print_summary_values (const bundle self)
    /* Print actual summary values. */

    loop j=1..rows(self.parameter_matrix)

        printf "%d|%d|%d", self.parameter_matrix[j,1], self.parameter_matrix[j,2], self.parameter_matrix[j,3]

        if data_has_seasonality()
            printf " \t %d|%d|%d", self.parameter_matrix[j,4], self.parameter_matrix[j,5], self.parameter_matrix[j,6]
        endif

        printf " %10.3f %10.3f %10.3f\n", self.criteria_values[j,1], self.criteria_values[j,2], self.criteria_values[j,3]
    endloop
end function

function void print_summary_intro (const bundle self)
    printf "\n*******************************************************************\n"
    printf "Summary results of ARIMA model combinations\n"
    print "The asterisks below indicate the best (that is, minimized) values of the"
    print "respective information criteria, AIC = Akaike criterion, BIC = Schwarz"
    print "Bayesian criterion and HQC = Hannan-Quinn criterion."
    printf "Common sample: %s to %s", self.sample_start, self.sample_end
end function

function void print_auto_arima_results (const bundle self)
    /* Summarize parameter results for each information criteria. */

    print_summary_intro(self)
   print_summary_header()
   print_summary_values(self)
   printf "\n*******************************************************************\n\n"
end function


function string get_auto_arima_command (const bundle self,
                                    const string info_criteria,
                                    const int model_rank)
    /* Compile gretl command of a model selected by information criteria and rank. */

    matrix beta = get_auto_arima_parameters(self, info_criteria, model_rank)

    string cmd = sprintf("arima %d %d %d", beta[1], beta[2], beta[3])
    if data_has_seasonality()
        cmd += sprintf(" ; %d %d %d", beta[4], beta[5], beta[6])
    endif
    cmd += sprintf(" ; %s %s %s", self.name_yseries, self.name_xlist, self.arima_model_options_string)

    return cmd
end function


function void rank_models_by_criteria (bundle *self)
    /* Rank models by information criteria. */

    matrix criteria_values = seq(1, n_combinations(self))' ~ self.criteria_values
    matrix model_rank_by_criteria = mshape(NA, rows(self.criteria_values), cols(self.criteria_values))
    #cnameset(model_rank_by_criteria, get_info_criteria_names())
    strings criteria_names = get_info_criteria_names()

    loop foreach i criteria_names
        model_rank_by_criteria[,i] = msortby(criteria_values, 1+i)[,1]
    endloop

    cnameset(model_rank_by_criteria, criteria_names)
    self.model_rank_by_criteria = model_rank_by_criteria
end function


function void get_parameters (const matrix parameter_matrix,
                            scalar *p,
                            scalar *d,
                            scalar *q,
                            scalar *P[null],
                            scalar *D[null],
                            scalar *Q[null])
     /* Retrieve sarima parameters from overall parameter matrix. */

     scalar p = parameter_matrix[1]
     scalar d = parameter_matrix[2]
     scalar q = parameter_matrix[3]
     if data_has_seasonality()
        scalar P = parameter_matrix[4]
        scalar D = parameter_matrix[5]
        scalar Q = parameter_matrix[6]
     endif
 end function


function void estimate_models (bundle *self)
    /* Estimate SARIMAX models for all parameter combinations. */

    series y = self.y
    list xlist = self.xlist
    matrix self.criteria_values = mshape(NA, rows(self.parameter_matrix), 3)
    cnameset(self.criteria_values, "AIC BIC HQC")

    # Restrict the data set to the least common sample to ensure that information criteria a comparable
    # TODO:is this offset computation correct?
    scalar offset = max(self.parameter_matrix)
    smpl +offset ;
    string self.sample_start = obslabel($t1)
    string self.sample_end = obslabel($t2)

    loop i=1..rows(self.parameter_matrix)
        self.criteria_values[i,] = arima_estimation_get_info_crits(y, xlist, self, $i)
    endloop
end function


function matrix arima_estimation_get_info_crits (const series y,
                                                const list xlist,
                                                const bundle self,
                                                const int parameter_set_id[1::])
    /* Actual estimation of SARIMAX model and computation of information criteria. */

    string arima_model_options_string = self.arima_model_options_string
    arima_model_options_string += (self.verbose == 0) ? self.arima_model_options_string : (self.verbose == 1 ? "--quiet" : "--verbose")
    scalar p, d, q, P, D, Q
    matrix crits = mshape(NA, 1, nelem(get_info_criteria_names()))

    get_parameters(self.parameter_matrix[parameter_set_id,], &p, &d, &q, &P, &D, &Q)

    if data_has_seasonality()
        catch arima p d q ; P D Q; y xlist @arima_model_options_string
    else
        catch arima p d q ; y xlist @arima_model_options_string
    endif

    if $error
        if self.verbose
            printWarning(sprintf("Failed to estimated SARIMAX(%d,%d,%d,%d,%d,%d) model. Ignored.", p, d, q, P, D, Q))
        endif
    else
        strings criteria = get_info_criteria_names()
        loop foreach i criteria
            string crit = sprintf("$%s", criteria[i])
            crits[i] = @crit
        endloop
    endif

    return crits
end function


function matrix get_parameter_matrix (const bundle self)
    /* Prepare matrix with all parameter combinations for ARIMA. */

    if data_has_seasonality()
        matrix combs = sarima_parameter_matrix(self)
    else
        matrix combs = arima_parameter_matrix(self)
    endif
    cnameset(combs, get_parameter_names())

    return combs
end function


function scalar n_lags (const int min_lag[0::], const int max_lag[0::])
    errorif(max_lag < min_lag, "Maximum lag cannot be lower than minimum lag.")
    return 1 + max_lag - min_lag
end function


function matrix sarima_parameter_matrix (const bundle self)
    /* Prepare the parameter combindations for SARIMA. */

    scalar k = 6        # p, d, q, P, D, Q
    scalar n_p = n_lags(self.min_p, self.max_p)
    scalar n_d = n_lags(self.min_d, self.max_d)
    scalar n_q = n_lags(self.min_q, self.max_q)
    scalar n_P = n_lags(self.min_P, self.max_P)
    scalar n_D = n_lags(self.min_D, self.max_D)
    scalar n_Q = n_lags(self.min_Q, self.max_Q)

    scalar n_rows = n_p * n_d * n_q * n_P * n_D * n_Q
    matrix combs = mshape(NA, n_rows, k)
    scalar repeat = 1

    # start with Q (the rightest variable)
    matrix m = ones(n_Q, (n_rows/n_Q)) .* seq(self.min_Q, self.max_Q)'
    combs[,6] = vec(m)

    repeat *= n_Q
    matrix m = ones(n_D, repeat) .* seq(self.min_D, self.max_D)'
    m = vec(m')
    scalar factor = n_p * n_d * n_q * n_P
    combs[,5] = vec(m .* ones(rows(m), factor))

    repeat *= n_D
    matrix m = ones(n_P, repeat) .* seq(self.min_P, self.max_P)'
    m = vec(m')
    scalar factor = n_p * n_d * n_q
    combs[,4] = vec(m .* ones(rows(m), factor))

    repeat *= n_P
    matrix m = ones(n_q, repeat) .* seq(self.min_q, self.max_q)'
    m = vec(m')
    scalar factor = n_p * n_d
    combs[,3] = vec(m .* ones(rows(m), factor))

    repeat *= n_q
    matrix m = ones(n_d, repeat) .* seq(self.min_d, self.max_d)'
    m = vec(m')
    scalar factor = n_p
    combs[,2] = vec(m .* ones(rows(m), factor))

    repeat *= n_d
    matrix m = ones(n_p, repeat) .* seq(self.min_p, self.max_p)'
    m = vec(m')
    combs[,1] = vec(m')

    return combs
end function

/*
function scalar update_repeat (const int repeat, const int multiply_by)
    return repeat * multiply_by
end function
*/

function matrix arima_parameter_matrix (const bundle self)
    /* Prepare the parameter combindations for ARIMA. */

    scalar k = 3        # p, d, q
    scalar n_p = n_lags(self.min_p, self.max_p)
    scalar n_d = n_lags(self.min_d, self.max_d)
    scalar n_q = n_lags(self.min_q, self.max_q)

    scalar n_rows = n_p * n_d * n_q
    matrix combs = mshape(NA, n_rows, k)
    scalar repeat = 1

    # start with q (the rightest variable)
    matrix m = ones(n_q, (n_rows/n_q)) .* seq(self.min_q, self.max_q)'
    combs[,3] = vec(m)

    repeat *= n_q
    matrix m = ones(n_d, repeat) .* seq(self.min_d, self.max_d)'
    m = vec(m')
    combs[,2] = vec(m .* ones(rows(m), n_p))

    repeat *= n_d
    matrix m = ones(n_p, repeat) .* seq(self.min_p, self.max_p)'
    combs[,1] = vec(m')

    return combs
end function


# TODO: many more options may be added -- see 'help arima'
function void prepare_arima_options_string (bundle *self)
    /* Compile various option strings for arima command. */

    string arima_model_options_string = ""

    arima_model_options_string = (self.intercept == FALSE) ? "--nc " : arima_model_options_string
    arima_model_options_string = (self.estimation_method == "conditional_ml") ? "--conditional" : arima_model_options_string

    self.arima_model_options_string = arima_model_options_string
end function


function void drop_intercept_from_xlist (bundle *self)
    /* Drop intercept from xlist if it should not enter the model. */

    if inlist(self.xlist, "const") && self.intercept == FALSE
        self.xlist -= const
        if self.verbose
            printInfo("Intercept has been dropped.")
        endif
    endif
end function


# TODO: test
function scalar estimation_method_supported (const bundle self)
    /* */

    self.estimation_method = tolower(self.estimation_method)
    if instrings(self.methods_supported, self.estimation_method)
        return 1
    else
        printWarning(sprintf("Estimation method '%s' not supported.",\
          self.estimation_method))
        printInfo(sprintf("Will switch to %s method.", self.methods_supported[1]))
        self.estimation_method = self.methods_supported[1]
        return 0
    endif
end function


function void printInfo (const string s)
    printf "\nInfo: %s\n", s
end function

function void printWarning (const string s)
    printf "\nWarning: %s\n", s
end function

function void printError (const string s)
    printf "\nError: %s\n", s
end function



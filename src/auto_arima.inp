function void y_has_zero_values (bundle *self)
    /* Check whether y includes only zero values.
    return: 0 if not zero or negative values, otherwise 1. */

    series y = self.y
    smpl y --no-missing

    if self.verbose > 0 && (sum(y == 0) > 0) ? TRUE : FALSE
        printWarning(sprintf("Endogenous '%s' includes only zero values", self.name_endo))
        self.error = TRUE
    endif

end function


function void add_intercept_to_xlist (bundle *self)
    /* Add intercept to xlist if it should enter the model. */

    if !inlist(self.xlist, "const") && self.intercept == TRUE
        if self.verbose == 1
            printInfo("Intercept added to xlist as you set intercept == TRUE")
        endif
        self.xlist += const
    endif
end function


function void do_initial_checks (bundle *self)
    /* Helper function perfoming some initial checks */

    y_has_zero_values(&self)
    drop_intercept_from_xlist(&self)
end function

function scalar data_has_seasonality (void)
    /* Flag seasonality of data set */

    return ($pd > 1) ? 1 : 0
end function


function bundle set_bundle_and_get_defaults (const series y,
                                        bundle opts[null])
    /* Compile self bundle by merging eventual information
    from opts-bundle. */

    if !exists(opts)
        bundle opts = null
    endif

    bundle self = default_values(y)
    self = opts + self			# override defaults
    self.name_endo = argname(y)

    return self
end function


function bundle default_values (const series y)
    /* Set default values */

    bundle self = null
    scalar self.error = FALSE
    scalar self.y_is_always_zero = FALSE
    scalar self.intercept = TRUE
    scalar self.seasonal = data_has_seasonality()
    scalar self.verbose = 1
    list self.xlist = null

    strings self.methods_supported  = defarray("exact_ml", "conditional_ml")
    string self.estimation_method = "exact_ml"

    # arima parameters
    scalar self.min_p = 0
    scalar self.max_p = 1   # TODO: $pd
    scalar self.min_d = 1
    scalar self.max_d = 1
    scalar self.min_q = 1
    scalar self.max_q = 1

    # seasonal arima parameters
    if self.seasonal
        scalar self.min_D = 1		# TODO: makes sense?
        scalar self.max_D = 1
        scalar self.min_P = 0
        scalar self.max_P = 1
        scalar self.min_Q = 0
        scalar self.max_Q = 1
    endif

    # TODO: check for what these are
    #    scalar self.stationary = FALSE
    #    scalar self.stepwise = TRUE
    #    scalar self.nmodels = 94,
    #  trace = FALSE,
    #  approximation = (length(x) > 150 | frequency(x) > 12),
    #  method = NULL,
    #  truncate = NULL,
    #  test = c("kpss", "adf", "pp"),
    #  test.args = list(),
    #  seasonal.test = c("seas", "ocsb", "hegy", "ch"),
    #  seasonal.test.args = list(),
    #  allowdrift = TRUE,
    #  allowmean = TRUE,
    #  lambda = NULL,
    #  biasadj = FALSE,
    #  parallel = FALSE,
    #  num.cores = 2,

    return self
end function


function strings get_parameter_names (const bundle self)
    if self.seasonal
        return defarray("p", "d", "q", "P", "D", "Q")
    else
        return defarray("p", "d", "q")
    endif
end function


function scalar n_combinations (const bundle self)
    /* Compute number of parameter combinations. */

    scalar n = 1
    strings parameters = get_parameter_names(self)

    loop foreach i parameters
        string param = parameters[i]
        scalar n *= (1 + self.max_@param - self.min_@param)
    endloop

    return n
end function


function bundle auto_arima (const series y "Endogenous",
                            const list xlist[null] "Exogenous",
                            bundle opts[null] "Parameter bundle")

    # TODO: User passes a bundle with key-values referencing to min_/max_p etc

    if !exists(opts)
        bundle opts = null
    endif
    bundle self = set_bundle_and_get_defaults(y, opts)

    series self.y = y
    list self.xlist = xlist

    do_initial_checks(&self)
    if self.error
        return self
    endif

    prepare_arima_option_string(&self)

    scalar self.n_combinations = n_combinations(self)
    # TODO: depends on seasonal: yes/no
    matrix self.get_parameter_matrix = get_parameter_matrix(self)

    # loop over self.parameter_combinations
    # estimate models
    # store information criteria
    # compare and sort models by criteria

    return self
end function


function matrix get_parameter_matrix (const bundle self)
    /* Prepare matrix with all parameter combinations for ARIMA. */

    if data_has_seasonality()
        return sarima_parameter_matrix(self)
    else
        return arima_parameter_matrix(self)
    endif
end function


function scalar n_lags (const int min_lag[0::], const int max_lag[0::])
    return 1 + max_lag - min_lag
end function


function matrix sarima_parameter_matrix (const bundle self)
    /* Prepare the parameter combindations for SARIMA. */

    scalar k = 6        # p, d, q, P, D, Q
    scalar n_p = n_lags(self.min_p, self.max_p)
    scalar n_d = n_lags(self.min_d, self.max_d)
    scalar n_q = n_lags(self.min_q, self.max_q)
    scalar n_P = n_lags(self.min_P, self.max_P)
    scalar n_D = n_lags(self.min_D, self.max_D)
    scalar n_Q = n_lags(self.min_Q, self.max_Q)

    scalar n_rows = n_p * n_d * n_q * n_P * n_D * n_Q
    matrix combs = mshape(NA, n_rows, k)

    # start with Q (the rightest variable)
    matrix m = ones(n_Q, (n_rows/n_Q)) .* seq(self.min_Q, self.max_Q)'
    combs[,6] = vec(m)

    matrix m = ones(n_D, n_Q) .* seq(self.min_D, self.max_D)'
    m = vec(m')
    scalar factor = n_P * n_q * n_d * n_p
    combs[,5] = vec(m .* ones(rows(m), factor))


*** HIER WEITERMACHEN ***
    matrix m = ones(n_P, n_D) .* seq(self.min_P, self.max_P)'
    m = vec(m')
    scalar factor = n_q * n_d * n_p
    combs[,4] = vec(m .* ones(rows(m), factor))


    matrix m = ones(n_p, n_q * n_d) .* seq(self.min_p, self.max_p)'
    combs[,1] = vec(m')

    return combs
end function


function matrix arima_parameter_matrix (const bundle self)
    /* Prepare the parameter combindations for ARIMA. */

    scalar k = 3        # p, d, q
    scalar n_p = n_lags(self.min_p, self.max_p)
    scalar n_d = n_lags(self.min_d, self.max_d)
    scalar n_q = n_lags(self.min_q, self.max_q)

    scalar n_rows = n_p * n_d * n_q
    matrix combs = mshape(NA, n_rows, k)

    # start with q (the rightest variable)
    matrix m = ones(n_q, (n_rows/n_q)) .* seq(self.min_q, self.max_q)'
    combs[,3] = vec(m)

    matrix m = ones(n_d, n_q) .* seq(self.min_d, self.max_d)'
    m = vec(m')
    combs[,2] = vec(m .* ones(rows(m), n_p))

    matrix m = ones(n_p, n_q * n_d) .* seq(self.min_p, self.max_p)'
    combs[,1] = vec(m')

    return combs
end function


function void prepare_arima_option_string (bundle *self)
    /* */

    string self.arima_option_string = ""
    if self.verbose == 0
        self.arima_option_string += "--quiet "
    elif self.verbose == 2
        self.arima_option_string += "--verbose "
    endif

    if self.intercept == FALSE
        self.arima_option_string += "--nc "
    endif

    if self.estimation_method == "conditional_ml"
        self.arima_option_string += "--conditional "
    endif

    # TODO: many more options may be added -- see 'help arima'
end function


function void drop_intercept_from_xlist (bundle *self)
    /* Drop intercept from xlist if it should not enter the model. */

    if inlist(self.xlist, "const") && self.intercept == FALSE
        if self.verbose == 1
            printInfo("Intercept dropped as you set intercept == FALSE")
        endif
        self.xlist -= const
    endif
end function


# TODO: test
function scalar estimation_method_supported (const bundle self)
    /* */

    self.estimation_method = tolower(self.estimation_method)
    if instrings(self.methods_supported, self.estimation_method)
        return 1
    else
        printWarning(sprintf("Estimation method '%s' not supported.",\
          self.estimation_method))
        printInfo(sprintf("Will switch to %s method.", self.methods_supported[1]))
        self.estimation_method = self.methods_supported[1]
        return 0
    endif
end function


function void printInfo (const string s)
    printf "\nInfo: %s\n", s
end function

function void printWarning (const string s)
    printf "\nWarning: %s\n", s
end function

function void printError (const string s)
    printf "\nError: %s\n", s
end function


